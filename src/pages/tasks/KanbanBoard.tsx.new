import { useCallback, useEffect, useMemo, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { Task } from '@/types/taskStorage';
import { RootState } from '@/store';
import { AssignmentDropZone } from '@/components/tasks/AssignmentDropZone';
import { DraggableTaskItem } from '@/components/tasks/DraggableTaskItem';
import { useAuth } from '@/hooks/useAuth';
import useDemoMode from '@/utils/useDemoMode';
import { fetchTasks, updateTask, deleteTask, toggleTaskStatus } from '@/store/TaskActions';
import { TaskForm } from './TaskForm';
import { DeleteCompletedModal } from '@/modals/DeleteTasksPop';
import { LoginPromptModal } from '@/modals/LoginPromptModal';
import { SortMenu } from './SortMenu';
import { TaskListMenu } from '@/modals/TaskListMenu';
import { WorkspaceSelectionModal } from '@/modals/WorkspaceSelectionModal';
import { AssignmentSortConfig, CollapsedColumns, ColumnMenuState } from '@/types/kanban';

const KanbanBoardContent: React.FC = () => {
  const dispatch = useDispatch();
  const { isLoggedIn } = useAuth();
  const {
    isDemo,
    demoTasks,
    loginPromptOpen,
    showLoginPrompt,
    closeLoginPrompt,
  } = useDemoMode();
  
  const tasks = useSelector((state: RootState) => isDemo ? demoTasks : state.tasks.tasks);
  const activeWorkspace = useSelector((state: RootState) => state.workspace.activeWorkspace);
  const workspaces = useSelector((state: RootState) => state.workspace.workspaces);

  // State
  const [showTaskForm, setShowTaskForm] = useState(false);
  const [editingTask, setEditingTask] = useState<Task | null>(null);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [taskToDelete, setTaskToDelete] = useState<string | null>(null);
  const [showDeleteCompletedModal, setShowDeleteCompletedModal] = useState(false);
  const [contextMenu, setContextMenu] = useState<{x: number, y: number, task: Task} | null>(null);
  const [columnMenu, setColumnMenu] = useState<ColumnMenuState | null>(null);
  const [sortMenu, setSortMenu] = useState<{x: number, y: number, assignmentId: string} | null>(null);
  const [collapsedColumns, setCollapsedColumns] = useState<CollapsedColumns>({});
  const [assignmentSortConfig, setAssignmentSortConfig] = useState<AssignmentSortConfig>({});
  const [taskOrder, setTaskOrder] = useState<Record<string, string[]>>({});
  const [selectedAssignment, setSelectedAssignment] = useState<string | null>(null);
  const [showWorkspaceSelection, setShowWorkspaceSelection] = useState(false);
  const [assignmentToMove, setAssignmentToMove] = useState<string | null>(null);

  // Filter tasks based on active workspace
  const filteredTasks = useMemo(() => {
    if (!activeWorkspace) return [];
    return tasks.filter(task => task.workspace_id === activeWorkspace.id);
  }, [tasks, activeWorkspace]);

  // Group tasks by assignment
  const groupTasksByAssignment = useCallback((tasksToGroup: Task[]) => {
    return tasksToGroup.reduce<Record<string, Task[]>>((acc, task) => {
      const assignment = task.assignment || "No assignment";
      if (!acc[assignment]) acc[assignment] = [];
      acc[assignment].push(task);
      return acc;
    }, {});
  }, []);

  // Sort tasks based on the current sort configuration
  const sortTasks = useCallback((tasks: Task[], assignment: string) => {
    const sortConfig = assignmentSortConfig[assignment];
    if (!sortConfig) return [...tasks];

    return [...tasks].sort((a, b) => {
      let comparison = 0;
      
      switch (sortConfig.type) {
        case 'title':
          comparison = a.title.localeCompare(b.title);
          break;
        case 'deadline':
          comparison = (a.due_date || '').localeCompare(b.due_date || '');
          break;
        case 'difficulty':
          const difficultyOrder = { 'easy': 1, 'medium': 2, 'hard': 3 };
          comparison = (difficultyOrder[a.priority as keyof typeof difficultyOrder] || 4) - 
                      (difficultyOrder[b.priority as keyof typeof difficultyOrder] || 4);
          break;
        case 'created':
          comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
          break;
      }

      return sortConfig.direction === 'asc' ? comparison : -comparison;
    });
  }, [assignmentSortConfig]);

  // Get grouped and sorted tasks
  const { completedTasks, incompletedByAssignment } = useMemo(() => {
    const completed = filteredTasks.filter(task => task.completed);
    const incompleted = filteredTasks.filter(task => !task.completed);
    
    const groupedIncomplete = groupTasksByAssignment(incompleted);
    const sortedGroups: Record<string, Task[]> = {};
    
    Object.keys(groupedIncomplete).forEach(assignment => {
      sortedGroups[assignment] = sortTasks(groupedIncomplete[assignment], assignment);
    });
    
    return {
      completedTasks: completed,
      incompletedByAssignment: sortedGroups
    };
  }, [filteredTasks, groupTasksByAssignment, sortTasks]);

  // Handle task drop
  const handleTaskDrop = useCallback(async (taskId: string, newAssignment: string) => {
    const task = tasks.find(t => t.id === taskId);
    if (!task || task.assignment === newAssignment) return;
    
    try {
      await dispatch(updateTask({ ...task, assignment: newAssignment }));
    } catch (error) {
      console.error('Failed to update task assignment:', error);
    }
  }, [dispatch, tasks]);

  // Handle task completion toggle
  const handleToggleCompletion = useCallback(async (taskId: string) => {
    if (!isLoggedIn) {
      showLoginPrompt();
      return;
    }
    try {
      await dispatch(toggleTaskStatus(taskId));
    } catch (error) {
      console.error('Failed to toggle task status:', error);
    }
  }, [dispatch, isLoggedIn, showLoginPrompt]);

  // Handle task deletion
  const handleDeleteTask = useCallback(async (taskId: string) => {
    if (!isLoggedIn) {
      showLoginPrompt();
      return;
    }
    try {
      await dispatch(deleteTask(taskId));
    } catch (error) {
      console.error('Failed to delete task:', error);
    }
  }, [dispatch, isLoggedIn, showLoginPrompt]);

  // Handle task edit
  const handleEditTask = useCallback((task: Task) => {
    setEditingTask(task);
    setShowTaskForm(true);
  }, []);

  // Handle add new task
  const handleAddTask = useCallback((assignment?: string) => {
    if (!isLoggedIn) {
      showLoginPrompt();
      return;
    }
    setSelectedAssignment(assignment || null);
    setEditingTask(null);
    setShowTaskForm(true);
  }, [isLoggedIn, showLoginPrompt]);

  // Handle context menu
  const handleTaskContextMenu = useCallback((e: React.MouseEvent, task: Task) => {
    e.preventDefault();
    setContextMenu({
      x: e.clientX,
      y: e.clientY,
      task
    });
  }, []);

  // Close all modals
  const closeAllModals = useCallback(() => {
    setShowTaskForm(false);
    setEditingTask(null);
    setContextMenu(null);
    setColumnMenu(null);
    setSortMenu(null);
  }, []);

  // Load initial data
  useEffect(() => {
    if (activeWorkspace) {
      dispatch(fetchTasks());
    }
  }, [activeWorkspace, dispatch]);

  // No tasks view
  if (filteredTasks.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center h-full text-gray-500">
        <p className="mb-4">No tasks found for this workspace.</p>
        <button
          onClick={() => handleAddTask()}
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
        >
          Add Your First Task
        </button>
      </div>
    );
  }

  return (
    <div className="flex-1 overflow-auto p-4">
      {/* Task columns */}
      <div className="flex space-x-4 h-full min-h-0">
        {Object.entries(incompletedByAssignment).map(([assignment, tasks]) => (
          <AssignmentDropZone
            key={assignment}
            assignment={assignment}
            onDrop={handleTaskDrop}
            className="flex-1 min-w-64 max-w-md bg-white rounded-lg shadow p-4 flex flex-col"
          >
            <div className="flex justify-between items-center mb-4">
              <h3 className="font-semibold text-lg">{assignment}</h3>
              <div className="flex space-x-2">
                <button
                  onClick={() => handleAddTask(assignment)}
                  className="text-blue-500 hover:text-blue-700"
                  title="Add task"
                >
                  +
                </button>
              </div>
            </div>
            
            <div className="flex-1 overflow-y-auto space-y-2">
              {tasks.map(task => (
                <DraggableTaskItem
                  key={task.id}
                  task={task}
                  onToggleCompletion={handleToggleCompletion}
                  onDelete={handleDeleteTask}
                  onEditTask={handleEditTask}
                  onContextMenu={handleTaskContextMenu}
                />
              ))}
            </div>
          </AssignmentDropZone>
        ))}
      </div>

      {/* Task Form Modal */}
      {showTaskForm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <TaskForm
              initialTask={editingTask}
              defaultAssignment={selectedAssignment}
              onClose={closeAllModals}
            />
          </div>
        </div>
      )}

      {/* Context Menu */}
      {contextMenu && (
        <div
          className="fixed bg-white shadow-lg rounded-md py-1 z-50"
          style={{
            top: contextMenu.y,
            left: contextMenu.x,
          }}
          onClick={() => setContextMenu(null)}
        >
          <button
            onClick={() => handleEditTask(contextMenu.task)}
            className="w-full text-left px-4 py-2 hover:bg-gray-100"
          >
            Edit
          </button>
          <button
            onClick={() => {
              handleDeleteTask(contextMenu.task.id);
              setContextMenu(null);
            }}
            className="w-full text-left px-4 py-2 text-red-500 hover:bg-red-50"
          >
            Delete
          </button>
        </div>
      )}

      {/* Login Prompt */}
      <LoginPromptModal
        isOpen={loginPromptOpen}
        onClose={closeLoginPrompt}
      />
    </div>
  );
};

const KanbanBoard: React.FC = () => {
  return (
    <DndProvider backend={HTML5Backend}>
      <KanbanBoardContent />
    </DndProvider>
  );
};

export default KanbanBoard;
